"""
Scene Builder — converts a beat config into a self-contained Manim .py file.

Each generated file:
  - Imports from the mathviz scenes package
  - Calls build_beat_scene(beat, style) to get the base scene class
  - Defines a Scene subclass with total_duration and audio_file injected
  - Is runnable by `manim render <file.py> <SceneName> -qm`
"""

from __future__ import annotations

import json
import re
from pathlib import Path

# Project root — so generated files can add it to sys.path
PROJECT_ROOT = Path(__file__).resolve().parent.parent

_SCENE_FILE_TEMPLATE = '''\
# Auto-generated by MathViz Engine — do not edit.
import sys, os, json

_PROJECT_ROOT = {project_root!r}
if _PROJECT_ROOT not in sys.path:
    sys.path.insert(0, _PROJECT_ROOT)

os.environ.setdefault("PYTHONIOENCODING", "utf-8")
os.environ.setdefault("PYTHONUTF8", "1")

from scenes import build_beat_scene as _build

_BEAT  = json.loads({beat_json_repr})
_STYLE = json.loads({style_json_repr})
_TOTAL_DURATION = {total_duration}
_AUDIO_FILE = {audio_file_repr}

_BaseClass = _build(_BEAT, _STYLE)


class {class_name}(_BaseClass):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.total_duration = _TOTAL_DURATION
        self.audio_file = _AUDIO_FILE
'''


def _to_class_name(beat_id: str) -> str:
    """Convert a beat_id to a valid Python class name."""
    clean = re.sub(r"[^a-zA-Z0-9]", "_", beat_id)
    if clean and clean[0].isdigit():
        clean = "B" + clean
    return f"MathVizScene_{clean}"


def build_scene_file(
    beat_config: dict,
    style: dict,
    total_duration: float,
    audio_path: str | Path | None,
    output_file: Path,
) -> tuple[Path, str]:
    """
    Write a self-contained Manim .py file for one beat.

    Args:
        beat_config:    Beat dict from the scene plan.
        style:          Global style dict {theme, accent_color, ...}.
        total_duration: Exact duration the scene should run (from TTS audio).
        audio_path:     Path to the .wav audio file, or None if no audio.
        output_file:    Path where the generated .py file will be written.

    Returns:
        (output_file path, scene class name)
    """
    beat_id    = beat_config.get("beat_id", "beat")
    class_name = _to_class_name(beat_id)

    beat_json  = json.dumps(beat_config,  ensure_ascii=False)
    style_json = json.dumps(style,        ensure_ascii=False)

    audio_file_repr = repr(str(audio_path)) if audio_path else repr(None)

    source = _SCENE_FILE_TEMPLATE.format(
        project_root    = str(PROJECT_ROOT),
        beat_json_repr  = repr(beat_json),
        style_json_repr = repr(style_json),
        total_duration  = round(total_duration, 3),
        audio_file_repr = audio_file_repr,
        class_name      = class_name,
    )

    output_file = Path(output_file)
    output_file.parent.mkdir(parents=True, exist_ok=True)
    output_file.write_text(source, encoding="utf-8")

    return output_file, class_name


def build_all_scene_files(
    beats: list[dict],
    style: dict,
    durations: dict[str, float],
    audio_paths: dict[str, Path],
    scene_dir: Path,
) -> list[tuple[str, Path, str]]:
    """
    Build .py scene files for every beat.

    Returns:
        List of (beat_id, scene_file_path, scene_class_name)
    """
    results: list[tuple[str, Path, str]] = []
    for beat in beats:
        bid      = beat["beat_id"]
        duration = durations.get(bid, 10.0)
        audio    = audio_paths.get(bid)

        scene_file = scene_dir / f"scene_{bid}.py"
        file_path, class_name = build_scene_file(
            beat_config    = beat,
            style          = style,
            total_duration = duration,
            audio_path     = audio,
            output_file    = scene_file,
        )
        results.append((bid, file_path, class_name))

    return results
